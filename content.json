[{"title":"python装饰器","date":"2019-07-29T09:02:14.000Z","path":"2019/07/29/python装饰器/","text":"从一段看不懂的代码说起在python3-cookbook学习内联回调函数这一节时，样例代码(如下)看不懂，回去补了下装饰器技术相关内容。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253from queue import Queuefrom functools import wrapsdef apply_async(func, args, *, callback): result = func(*args) callback(result)class Async: def __init__(self, func, args): self.func = func self.args = argsdef inlined_async(func): @wraps(func) def wrapper(*args): f = func(*args) result_queue = Queue() result_queue.put(None) while True: result = result_queue.get() try: a = f.send(result) apply_async(a.func, a.args, callback=result_queue.put) except StopIteration: break return wrapperdef add(x, y): return x + y@inlined_asyncdef test(): r = yield Async(add, (2, 3)) print(r) r = yield Async(add, ('Hello', 'World')) print(r) for n in range(10): r = yield Async(add, (n, n)) print(r) print('GoodBye')if __name__ == '__main__': import multiprocessing pool = multiprocessing.Pool() apply_async = pool.apply_async test() 装饰器技术无参装饰器12345678910111213141516171819def use_logging(func): def wrapper(*args, **kwargs): print(args) print(kwargs) print('%s is running' % func.__name__) return func(*args, **kwargs) return wrapper@use_loggingdef bar(x): print('I am bar %d' % x)if __name__ == '__main__': # bar = use_logging(bar) bar(x=2) print(bar.__name__) 可见@use_logging的实际的工作就是bar = use_logging(bar) 有参装饰器12345678910111213141516171819202122232425def use_logging(level): if level == 'warn': def decorator(func): def wraper(*args, **kwargs): print('adfds') return func(*args) return wraper return decorator else: def decorator(func): print('wx') return func return decorator@use_logging(level='error')def foo(name='foo'): print('I an %s' % name)if __name__ == '__main__': foo() 如果直接对原有函数改动，违反开闭原则，引入装饰器，可以在新增额外功能的时候只是新增一个函数，而不是修改原来的代码 可以通过装饰器，在对原函数不做改动的情况下，增加额外的功能 装饰器是定义一个入参为函数的函数，然后通过在原有函数上面添加注解的方式，增加新功能。 Q:如上代码，为什么wraper函数能够获取原有函数的入参 装饰器修复技术@wrapsPython装饰器（decorator）在实现的时候，被装饰后的函数其实已经是另外一个函数了（函数名等函数属性会发生改变），为了不影响，Python的functools包中提供了一个叫wraps的decorator来消除这样的副作用。写一个decorator的时候，最好在实现之前加上functools的wrap，它能保留原有函数的名称和docstring。 1234567891011121314151617181920def my_decorator(func): def wrapper(*args, **kwargs): \"\"\"decorator\"\"\" print('Calling decorated function...') return func(*args, **kwargs) return wrapper@my_decoratordef example(): \"\"\"Docstring\"\"\" print('Called example function')def normallize(name): return name[0:1].upper() + name[1:].lower()print(example.__name__, example.__doc__) 执行结果：wrapper decorator 1234567891011121314151617181920from functools import wrapsdef my_decorator(func): @wraps(func) def wrapper(*args, **kwargs): \"\"\"decorator\"\"\" print('Calling decorated function...') return func(*args, **kwargs) return wrapper@my_decoratordef example(): \"\"\"Docstring\"\"\" print('Called example function') print(example.__name__, example.__doc__) 执行结果：example Docstring Why 为什么有这个技术 What 这个技术解决了什么问题 How 这个技术是怎么使用的 有什么问题","tags":[]},{"title":"软件设计方向选课分析","date":"2019-07-27T04:17:17.000Z","path":"2019/07/27/选课分析/","text":"公共必修课 工程硕士政治(2) 工程伦理(2) 工程硕士基础英语(2) 四选一 实用日语(2) 基础日语(2) 实用英语(2) 实用IT英语(2) 基础课 三选一 实用算法设计(3) 算法理论基础(3) 算法设计与分析(3) 四选一 概率论与数理统计(3) 组合数学(3) 形式化方法(3) 离散数学及其应用(3) 二选一 高级软件工程(3) 系统建模与分析 专业限选课(八选三) 软件体系结构(3) 编译工程(3) 高级网络技术(3) 软件测试方法和技术(3) 多媒体信号处理(3) 信息安全(3) 多核并行计算(3) 高级数据库技术(3) 专业任选课 分布式与云计算(3) 自然语言处理(2) Linux操作系统分析(3) 软件设计模式(3) 工程实践 毕业论文(6) 开题报告及中期检查(1) 工程实验综合(0.5) 五选一(1) EDA技术 信息安全实践 IOS应用开发 深度学习实践 网络程序设计 四选一(1) 设备驱动程序设计 python程序设计 Java面向对象技术 C++面向对象技术","tags":[]},{"title":"中科大常用网址整理","date":"2019-07-26T07:13:43.000Z","path":"2019/07/26/中科大常用网址整理/","text":"邮箱登陆：http://mail.ustc.edu.cn/coremail/index.jsp 软件学院信息化平台：http://mis.sse.ustc.edu.cn/default.aspx 中科大研究生信息平台：http://yjs.ustc.edu.cn/default.asp 招生系统登陆：http://enroll.sse.ustc.edu.cn/ssers2014/stupages/studentLogin.aspx 网络通：http://wlt.ustc.edu.cn/cgi-bin/ip 网络信息中心：https://ustcnet.ustc.edu.cn/ 校园信息门户：https://i.ustc.edu.cn/ 图书馆：http://lib.ustc.edu.cn/","tags":[]},{"title":"算法","date":"2019-07-03T08:54:33.000Z","path":"2019/07/03/算法/","text":"","tags":[]},{"title":"Hello World","date":"2019-07-03T06:31:43.863Z","path":"2019/07/03/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","tags":[]}]